<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>gedcom.element.individual API documentation</title>
<meta name="description" content="GEDCOM element consisting of tag `gedcom.tags.GEDCOM_TAG_INDIVIDUAL`">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gedcom.element.individual</code></h1>
</header>
<section id="section-intro">
<p>GEDCOM element consisting of tag <code><a title="gedcom.tags.GEDCOM_TAG_INDIVIDUAL" href="../tags.html#gedcom.tags.GEDCOM_TAG_INDIVIDUAL">GEDCOM_TAG_INDIVIDUAL</a></code></p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gedcom.element.individual.IndividualElement"><code class="flex name class">
<span>class <span class="ident">IndividualElement</span></span>
<span>(</span><span>level, pointer, tag, value, crlf='\n', multi_line=True)</span>
</code></dt>
<dd>
<div class="desc"><p>GEDCOM element</p>
<p>Each line in a GEDCOM file is an element with the format</p>
<p><code>level [pointer] tag [value]</code></p>
<p>where <code>level</code> and <code>tag</code> are required, and <code>pointer</code> and <code>value</code> are
optional.
Elements are arranged hierarchically according to their
level, and elements with a level of zero are at the top level.
Elements with a level greater than zero are children of their
parent.</p>
<p>A pointer has the format <code>@pname@</code>, where <code>pname</code> is any sequence of
characters and numbers. The pointer identifies the object being
pointed to, so that any pointer included as the value of any
element points back to the original object.
For example, an
element may have a <code>FAMS</code> tag whose value is <code>@F1@</code>, meaning that this
element points to the family record in which the associated person
is a spouse. Likewise, an element with a tag of <code>FAMC</code> has a value
that points to a family record in which the associated person is a
child.</p>
<p>See a GEDCOM file for examples of tags and their values.</p>
<p>Tags available to an element are seen here: <code><a title="gedcom.tags" href="../tags.html">gedcom.tags</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndividualElement(Element):

    def get_tag(self):
        return gedcom.tags.GEDCOM_TAG_INDIVIDUAL

    def is_deceased(self):
        &#34;&#34;&#34;Checks if this individual is deceased
        :rtype: bool
        &#34;&#34;&#34;
        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_DEATH:
                return True

        return False

    def is_child(self):
        &#34;&#34;&#34;Checks if this element is a child of a family
        :rtype: bool
        &#34;&#34;&#34;
        found_child = False

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_FAMILY_CHILD:
                found_child = True

        return found_child

    def is_private(self):
        &#34;&#34;&#34;Checks if this individual is marked private
        :rtype: bool
        &#34;&#34;&#34;
        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_PRIVATE:
                private = child.get_value()
                if private == &#39;Y&#39;:
                    return True

        return False

    def get_name(self):
        &#34;&#34;&#34;Returns an individual&#39;s names as a tuple: (`str` given_name, `str` surname)
        :rtype: tuple
        &#34;&#34;&#34;
        given_name = &#34;&#34;
        surname = &#34;&#34;

        # Return the first gedcom.tags.GEDCOM_TAG_NAME that is found.
        # Alternatively as soon as we have both the gedcom.tags.GEDCOM_TAG_GIVEN_NAME and _SURNAME return those.
        found_given_name = False
        found_surname_name = False

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_NAME:
                # Some GEDCOM files don&#39;t use child tags but instead
                # place the name in the value of the NAME tag.
                if child.get_value() != &#34;&#34;:
                    name = child.get_value().split(&#39;/&#39;)

                    if len(name) &gt; 0:
                        given_name = name[0].strip()
                        if len(name) &gt; 1:
                            surname = name[1].strip()

                    return given_name, surname

                for childOfChild in child.get_child_elements():

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_GIVEN_NAME:
                        given_name = childOfChild.get_value()
                        found_given_name = True

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SURNAME:
                        surname = childOfChild.get_value()
                        found_surname_name = True

                if found_given_name and found_surname_name:
                    return given_name, surname

        # If we reach here we are probably returning empty strings
        return given_name, surname

    def get_all_names(self):
        return [a.get_value() for a in self.get_child_elements() if a.get_tag() == gedcom.tags.GEDCOM_TAG_NAME]

    def surname_match(self, surname_to_match):
        &#34;&#34;&#34;Matches a string with the surname of an individual
        :type surname_to_match: str
        :rtype: bool
        &#34;&#34;&#34;
        (given_name, surname) = self.get_name()
        return regex.search(surname_to_match, surname, regex.IGNORECASE)

    @deprecated
    def given_match(self, name):
        &#34;&#34;&#34;Matches a string with the given name of an individual
        ::deprecated:: As of version 1.0.0 use `given_name_match()` method instead
        :type name: str
        :rtype: bool
        &#34;&#34;&#34;
        return self.given_name_match(name)

    def given_name_match(self, given_name_to_match):
        &#34;&#34;&#34;Matches a string with the given name of an individual
        :type given_name_to_match: str
        :rtype: bool
        &#34;&#34;&#34;
        (given_name, surname) = self.get_name()
        return regex.search(given_name_to_match, given_name, regex.IGNORECASE)

    def get_gender(self):
        &#34;&#34;&#34;Returns the gender of a person in string format
        :rtype: str
        &#34;&#34;&#34;
        gender = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_SEX:
                gender = child.get_value()

        return gender

    def get_birth_data(self):
        &#34;&#34;&#34;Returns the birth data of a person formatted as a tuple: (`str` date, `str` place, `list` sources)
        :rtype: tuple
        &#34;&#34;&#34;
        date = &#34;&#34;
        place = &#34;&#34;
        sources = []

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_BIRTH:
                for childOfChild in child.get_child_elements():

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                        place = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        sources.append(childOfChild.get_value())

        return date, place, sources

    def get_birth_year(self):
        &#34;&#34;&#34;Returns the birth year of a person in integer format
        :rtype: int
        &#34;&#34;&#34;
        date = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_BIRTH:
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date_split = childOfChild.get_value().split()
                        date = date_split[len(date_split) - 1]

        if date == &#34;&#34;:
            return -1
        try:
            return int(date)
        except ValueError:
            return -1

    def get_death_data(self):
        &#34;&#34;&#34;Returns the death data of a person formatted as a tuple: (`str` date, `str` place, `list` sources)
        :rtype: tuple
        &#34;&#34;&#34;
        date = &#34;&#34;
        place = &#34;&#34;
        sources = []

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_DEATH:
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                        place = childOfChild.get_value()
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        sources.append(childOfChild.get_value())

        return date, place, sources

    def get_death_year(self):
        &#34;&#34;&#34;Returns the death year of a person in integer format
        :rtype: int
        &#34;&#34;&#34;
        date = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_DEATH:
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date_split = childOfChild.get_value().split()
                        date = date_split[len(date_split) - 1]

        if date == &#34;&#34;:
            return -1
        try:
            return int(date)
        except ValueError:
            return -1

    @deprecated
    def get_burial(self):
        &#34;&#34;&#34;Returns the burial data of a person formatted as a tuple: (`str` date, `str´ place, `list` sources)
        ::deprecated:: As of version 1.0.0 use `get_burial_data()` method instead
        :rtype: tuple
        &#34;&#34;&#34;
        self.get_burial_data()

    def get_burial_data(self):
        &#34;&#34;&#34;Returns the burial data of a person formatted as a tuple: (`str` date, `str´ place, `list` sources)
        :rtype: tuple
        &#34;&#34;&#34;
        date = &#34;&#34;
        place = &#34;&#34;
        sources = []

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_BURIAL:
                for childOfChild in child.get_child_elements():

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                        place = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        sources.append(childOfChild.get_value())

        return date, place, sources

    @deprecated
    def get_census(self):
        &#34;&#34;&#34;Returns a list of censuses of an individual formatted as tuples: (`str` date, `str´ place, `list` sources)
        ::deprecated:: As of version 1.0.0 use `get_census_data()` method instead
        :rtype: list of tuple
        &#34;&#34;&#34;
        self.get_census_data()

    def get_census_data(self):
        &#34;&#34;&#34;Returns a list of censuses of an individual formatted as tuples: (`str` date, `str´ place, `list` sources)
        :rtype: list of tuple
        &#34;&#34;&#34;
        census = []

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_CENSUS:

                date = &#39;&#39;
                place = &#39;&#39;
                sources = []

                for childOfChild in child.get_child_elements():

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                        place = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        sources.append(childOfChild.get_value())

                census.append((date, place, sources))

        return census

    def get_last_change_date(self):
        &#34;&#34;&#34;Returns the date of when the person data was last changed formatted as a string
        :rtype: str
        &#34;&#34;&#34;
        date = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_CHANGE:
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()

        return date

    def get_occupation(self):
        &#34;&#34;&#34;Returns the occupation of a person
        :rtype: str
        &#34;&#34;&#34;
        occupation = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_OCCUPATION:
                occupation = child.get_value()

        return occupation

    def birth_year_match(self, year):
        &#34;&#34;&#34;Returns `True` if the given year matches the birth year of this person
        :type year: int
        :rtype: bool
        &#34;&#34;&#34;
        return self.get_birth_year() == year

    def birth_range_match(self, from_year, to_year):
        &#34;&#34;&#34;Checks if the birth year of a person lies within the given range
        :type from_year: int
        :type to_year: int
        :rtype: bool
        &#34;&#34;&#34;
        birth_year = self.get_birth_year()

        if from_year &lt;= birth_year &lt;= to_year:
            return True

        return False

    def death_year_match(self, year):
        &#34;&#34;&#34;Returns `True` if the given year matches the death year of this person
        :type year: int
        :rtype: bool
        &#34;&#34;&#34;
        return self.get_death_year() == year

    def death_range_match(self, from_year, to_year):
        &#34;&#34;&#34;Checks if the death year of a person lies within the given range
        :type from_year: int
        :type to_year: int
        :rtype: bool
        &#34;&#34;&#34;
        death_year = self.get_death_year()

        if from_year &lt;= death_year &lt;= to_year:
            return True

        return False

    def criteria_match(self, criteria):
        &#34;&#34;&#34;Checks if this individual matches all of the given criteria

        `criteria` is a colon-separated list, where each item in the
        list has the form [name]=[value]. The following criteria are supported:

        surname=[name]
             Match a person with [name] in any part of the `surname`.
        given_name=[given_name]
             Match a person with [given_name] in any part of the given `given_name`.
        birth=[year]
             Match a person whose birth year is a four-digit [year].
        birth_range=[from_year-to_year]
             Match a person whose birth year is in the range of years from
             [from_year] to [to_year], including both [from_year] and [to_year].

        :type criteria: str
        :rtype: bool
        &#34;&#34;&#34;

        # Check if criteria is a valid criteria and can be split by `:` and `=` characters
        try:
            for criterion in criteria.split(&#39;:&#39;):
                criterion.split(&#39;=&#39;)
        except ValueError:
            return False

        match = True

        for criterion in criteria.split(&#39;:&#39;):
            key, value = criterion.split(&#39;=&#39;)

            if key == &#34;surname&#34; and not self.surname_match(value):
                match = False
            elif key == &#34;name&#34; and not self.given_name_match(value):
                match = False
            elif key == &#34;birth&#34;:

                try:
                    year = int(value)
                    if not self.birth_year_match(year):
                        match = False
                except ValueError:
                    match = False

            elif key == &#34;birth_range&#34;:

                try:
                    from_year, to_year = value.split(&#39;-&#39;)
                    from_year = int(from_year)
                    to_year = int(to_year)
                    if not self.birth_range_match(from_year, to_year):
                        match = False
                except ValueError:
                    match = False

            elif key == &#34;death&#34;:

                try:
                    year = int(value)
                    if not self.death_year_match(year):
                        match = False
                except ValueError:
                    match = False

            elif key == &#34;death_range&#34;:

                try:
                    from_year, to_year = value.split(&#39;-&#39;)
                    from_year = int(from_year)
                    to_year = int(to_year)
                    if not self.death_range_match(from_year, to_year):
                        match = False
                except ValueError:
                    match = False

        return match</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gedcom.element.element.Element" href="element.html#gedcom.element.element.Element">Element</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gedcom.element.individual.IndividualElement.birth_range_match"><code class="name flex">
<span>def <span class="ident">birth_range_match</span></span>(<span>self, from_year, to_year)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the birth year of a person lies within the given range
:type from_year: int
:type to_year: int
:rtype: bool</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.birth_year_match"><code class="name flex">
<span>def <span class="ident">birth_year_match</span></span>(<span>self, year)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>True</code> if the given year matches the birth year of this person
:type year: int
:rtype: bool</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.criteria_match"><code class="name flex">
<span>def <span class="ident">criteria_match</span></span>(<span>self, criteria)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this individual matches all of the given criteria</p>
<p><code>criteria</code> is a colon-separated list, where each item in the
list has the form [name]=[value]. The following criteria are supported:</p>
<p>surname=[name]
Match a person with [name] in any part of the <code>surname</code>.
given_name=[given_name]
Match a person with [given_name] in any part of the given <code>given_name</code>.
birth=[year]
Match a person whose birth year is a four-digit [year].
birth_range=[from_year-to_year]
Match a person whose birth year is in the range of years from
[from_year] to [to_year], including both [from_year] and [to_year].</p>
<p>:type criteria: str
:rtype: bool</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.death_range_match"><code class="name flex">
<span>def <span class="ident">death_range_match</span></span>(<span>self, from_year, to_year)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the death year of a person lies within the given range
:type from_year: int
:type to_year: int
:rtype: bool</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.death_year_match"><code class="name flex">
<span>def <span class="ident">death_year_match</span></span>(<span>self, year)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>True</code> if the given year matches the death year of this person
:type year: int
:rtype: bool</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_all_names"><code class="name flex">
<span>def <span class="ident">get_all_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_birth_data"><code class="name flex">
<span>def <span class="ident">get_birth_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the birth data of a person formatted as a tuple: (<code>str</code> date, <code>str</code> place, <code>list</code> sources)
:rtype: tuple</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_birth_year"><code class="name flex">
<span>def <span class="ident">get_birth_year</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the birth year of a person in integer format
:rtype: int</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_burial"><code class="name flex">
<span>def <span class="ident">get_burial</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the burial data of a person formatted as a tuple: (<code>str</code> date, <code>str´ place,</code>list` sources)
::deprecated:: As of version 1.0.0 use <code>get_burial_data()</code> method instead
:rtype: tuple</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_burial_data"><code class="name flex">
<span>def <span class="ident">get_burial_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the burial data of a person formatted as a tuple: (<code>str</code> date, <code>str´ place,</code>list` sources)
:rtype: tuple</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_census"><code class="name flex">
<span>def <span class="ident">get_census</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of censuses of an individual formatted as tuples: (<code>str</code> date, <code>str´ place,</code>list` sources)
::deprecated:: As of version 1.0.0 use <code>get_census_data()</code> method instead
:rtype: list of tuple</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_census_data"><code class="name flex">
<span>def <span class="ident">get_census_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of censuses of an individual formatted as tuples: (<code>str</code> date, <code>str´ place,</code>list` sources)
:rtype: list of tuple</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_death_data"><code class="name flex">
<span>def <span class="ident">get_death_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the death data of a person formatted as a tuple: (<code>str</code> date, <code>str</code> place, <code>list</code> sources)
:rtype: tuple</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_death_year"><code class="name flex">
<span>def <span class="ident">get_death_year</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the death year of a person in integer format
:rtype: int</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_gender"><code class="name flex">
<span>def <span class="ident">get_gender</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the gender of a person in string format
:rtype: str</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_last_change_date"><code class="name flex">
<span>def <span class="ident">get_last_change_date</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the date of when the person data was last changed formatted as a string
:rtype: str</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an individual's names as a tuple: (<code>str</code> given_name, <code>str</code> surname)
:rtype: tuple</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_occupation"><code class="name flex">
<span>def <span class="ident">get_occupation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the occupation of a person
:rtype: str</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.given_match"><code class="name flex">
<span>def <span class="ident">given_match</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Matches a string with the given name of an individual
::deprecated:: As of version 1.0.0 use <code>given_name_match()</code> method instead
:type name: str
:rtype: bool</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.given_name_match"><code class="name flex">
<span>def <span class="ident">given_name_match</span></span>(<span>self, given_name_to_match)</span>
</code></dt>
<dd>
<div class="desc"><p>Matches a string with the given name of an individual
:type given_name_to_match: str
:rtype: bool</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.is_child"><code class="name flex">
<span>def <span class="ident">is_child</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this element is a child of a family
:rtype: bool</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.is_deceased"><code class="name flex">
<span>def <span class="ident">is_deceased</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this individual is deceased
:rtype: bool</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.is_private"><code class="name flex">
<span>def <span class="ident">is_private</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if this individual is marked private
:rtype: bool</p></div>
</dd>
<dt id="gedcom.element.individual.IndividualElement.surname_match"><code class="name flex">
<span>def <span class="ident">surname_match</span></span>(<span>self, surname_to_match)</span>
</code></dt>
<dd>
<div class="desc"><p>Matches a string with the surname of an individual
:type surname_to_match: str
:rtype: bool</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gedcom.element.element.Element" href="element.html#gedcom.element.element.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="gedcom.element.element.Element.add_child_element" href="element.html#gedcom.element.element.Element.add_child_element">add_child_element</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_child_elements" href="element.html#gedcom.element.element.Element.get_child_elements">get_child_elements</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_individual" href="element.html#gedcom.element.element.Element.get_individual">get_individual</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_level" href="element.html#gedcom.element.element.Element.get_level">get_level</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_multi_line_value" href="element.html#gedcom.element.element.Element.get_multi_line_value">get_multi_line_value</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_parent_element" href="element.html#gedcom.element.element.Element.get_parent_element">get_parent_element</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_pointer" href="element.html#gedcom.element.element.Element.get_pointer">get_pointer</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_tag" href="element.html#gedcom.element.element.Element.get_tag">get_tag</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_value" href="element.html#gedcom.element.element.Element.get_value">get_value</a></code></li>
<li><code><a title="gedcom.element.element.Element.new_child_element" href="element.html#gedcom.element.element.Element.new_child_element">new_child_element</a></code></li>
<li><code><a title="gedcom.element.element.Element.set_multi_line_value" href="element.html#gedcom.element.element.Element.set_multi_line_value">set_multi_line_value</a></code></li>
<li><code><a title="gedcom.element.element.Element.set_parent_element" href="element.html#gedcom.element.element.Element.set_parent_element">set_parent_element</a></code></li>
<li><code><a title="gedcom.element.element.Element.set_value" href="element.html#gedcom.element.element.Element.set_value">set_value</a></code></li>
<li><code><a title="gedcom.element.element.Element.to_gedcom_string" href="element.html#gedcom.element.element.Element.to_gedcom_string">to_gedcom_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gedcom.element.individual.NotAnActualIndividualError"><code class="flex name class">
<span>class <span class="ident">NotAnActualIndividualError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotAnActualIndividualError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gedcom.element" href="index.html">gedcom.element</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gedcom.element.individual.IndividualElement" href="#gedcom.element.individual.IndividualElement">IndividualElement</a></code></h4>
<ul class="">
<li><code><a title="gedcom.element.individual.IndividualElement.birth_range_match" href="#gedcom.element.individual.IndividualElement.birth_range_match">birth_range_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.birth_year_match" href="#gedcom.element.individual.IndividualElement.birth_year_match">birth_year_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.criteria_match" href="#gedcom.element.individual.IndividualElement.criteria_match">criteria_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.death_range_match" href="#gedcom.element.individual.IndividualElement.death_range_match">death_range_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.death_year_match" href="#gedcom.element.individual.IndividualElement.death_year_match">death_year_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_all_names" href="#gedcom.element.individual.IndividualElement.get_all_names">get_all_names</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_birth_data" href="#gedcom.element.individual.IndividualElement.get_birth_data">get_birth_data</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_birth_year" href="#gedcom.element.individual.IndividualElement.get_birth_year">get_birth_year</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_burial" href="#gedcom.element.individual.IndividualElement.get_burial">get_burial</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_burial_data" href="#gedcom.element.individual.IndividualElement.get_burial_data">get_burial_data</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_census" href="#gedcom.element.individual.IndividualElement.get_census">get_census</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_census_data" href="#gedcom.element.individual.IndividualElement.get_census_data">get_census_data</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_death_data" href="#gedcom.element.individual.IndividualElement.get_death_data">get_death_data</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_death_year" href="#gedcom.element.individual.IndividualElement.get_death_year">get_death_year</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_gender" href="#gedcom.element.individual.IndividualElement.get_gender">get_gender</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_last_change_date" href="#gedcom.element.individual.IndividualElement.get_last_change_date">get_last_change_date</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_name" href="#gedcom.element.individual.IndividualElement.get_name">get_name</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_occupation" href="#gedcom.element.individual.IndividualElement.get_occupation">get_occupation</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.given_match" href="#gedcom.element.individual.IndividualElement.given_match">given_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.given_name_match" href="#gedcom.element.individual.IndividualElement.given_name_match">given_name_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.is_child" href="#gedcom.element.individual.IndividualElement.is_child">is_child</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.is_deceased" href="#gedcom.element.individual.IndividualElement.is_deceased">is_deceased</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.is_private" href="#gedcom.element.individual.IndividualElement.is_private">is_private</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.surname_match" href="#gedcom.element.individual.IndividualElement.surname_match">surname_match</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gedcom.element.individual.NotAnActualIndividualError" href="#gedcom.element.individual.NotAnActualIndividualError">NotAnActualIndividualError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
